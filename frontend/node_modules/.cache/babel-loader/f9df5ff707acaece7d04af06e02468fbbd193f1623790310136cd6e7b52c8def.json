{"ast":null,"code":"\"use client\";\n\n// packages/react/focus-scope/src/FocusScope.tsx\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { jsx } from \"react/jsx-runtime\";\nvar AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar FOCUS_SCOPE_NAME = \"FocusScope\";\nvar FocusScope = React.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  React.useEffect(() => {\n    if (trapped) {\n      let handleFocusIn2 = function (event) {\n          if (focusScope.paused || !container) return;\n          const target = event.target;\n          if (container.contains(target)) {\n            lastFocusedElementRef.current = target;\n          } else {\n            focus(lastFocusedElementRef.current, {\n              select: true\n            });\n          }\n        },\n        handleFocusOut2 = function (event) {\n          if (focusScope.paused || !container) return;\n          const relatedTarget = event.relatedTarget;\n          if (relatedTarget === null) return;\n          if (!container.contains(relatedTarget)) {\n            focus(lastFocusedElementRef.current, {\n              select: true\n            });\n          }\n        },\n        handleMutations2 = function (mutations) {\n          const focusedElement = document.activeElement;\n          if (focusedElement !== document.body) return;\n          for (const mutation of mutations) {\n            if (mutation.removedNodes.length > 0) focus(container);\n          }\n        };\n      var handleFocusIn = handleFocusIn2,\n        handleFocusOut = handleFocusOut2,\n        handleMutations = handleMutations2;\n      document.addEventListener(\"focusin\", handleFocusIn2);\n      document.addEventListener(\"focusout\", handleFocusOut2);\n      const mutationObserver = new MutationObserver(handleMutations2);\n      if (container) mutationObserver.observe(container, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn2);\n        document.removeEventListener(\"focusout\", handleFocusOut2);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, {\n              select: true\n            });\n          }\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n  const handleKeyDown = React.useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container2 = event.currentTarget;\n      const [first, last] = getTabbableEdges(container2);\n      const hasTabbableElementsInside = first && last;\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container2) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    tabIndex: -1,\n    ...scopeProps,\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  });\n});\nFocusScope.displayName = FOCUS_SCOPE_NAME;\nfunction focusFirst(candidates, {\n  select = false\n} = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, {\n      select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\nfunction isHidden(node, {\n  upTo\n}) {\n  if (getComputedStyle(node).visibility === \"hidden\") return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo) return false;\n    if (getComputedStyle(node).display === \"none\") return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction focus(element, {\n  select = false\n} = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();\n  }\n}\nvar focusScopesStack = createFocusScopesStack();\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    }\n  };\n}\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\nfunction removeLinks(items) {\n  return items.filter(item => item.tagName !== \"A\");\n}\nvar Root = FocusScope;\nexport { FocusScope, Root };","map":{"version":3,"names":["React","useComposedRefs","Primitive","useCallbackRef","jsx","AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","cancelable","FOCUS_SCOPE_NAME","FocusScope","forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","useState","lastFocusedElementRef","useRef","composedRefs","node","focusScope","paused","pause","resume","current","useEffect","handleFocusIn2","handleFocusIn","event","target","contains","focus","select","handleFocusOut2","handleFocusOut","relatedTarget","handleMutations2","handleMutations","mutations","focusedElement","document","activeElement","body","mutation","removedNodes","length","addEventListener","mutationObserver","MutationObserver","observe","childList","subtree","removeEventListener","disconnect","focusScopesStack","add","previouslyFocusedElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","focusFirst","removeLinks","getTabbableCandidates","setTimeout","unmountEvent","remove","handleKeyDown","useCallback","isTabKey","key","altKey","ctrlKey","metaKey","container2","currentTarget","first","last","getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","div","tabIndex","ref","onKeyDown","displayName","candidates","candidate","findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","display","parentElement","isSelectableInput","HTMLInputElement","preventScroll","createFocusScopesStack","stack","activeFocusScope","arrayRemove","unshift","array","item","updatedArray","index","indexOf","splice","items","filter","Root"],"sources":["/home/peter/convo/frontend/node_modules/@radix-ui/react-focus-scope/src/FocusScope.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}